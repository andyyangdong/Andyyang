数据库
===
一、开启慢查询日志，捕获慢SQL

二、explain+慢SQL分析

三、show profile查询SQL语句在服务器中的执行细节和生命周期

四、SQL数据库服务器参数调优

###  **查询SQL**

*   可通过开启慢查询日志来找出较慢的SQL

*   sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库

#### **引擎**  表类型

##### MyISAM

*   不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁

*   不支持事务

*   不支持外键

*   不支持崩溃后的安全恢复

*   在表有读取查询的同时，支持往表中插入新纪录

##### InnoDB

*   支持行锁，采用MVCC来支持高并发

*   支持事务

*   支持外键

*   支持崩溃后的安全恢复

*   不支持全文索引

总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表

 ### **读写分离**
从库读主库写，一般不要采用双主或多主引入很多复杂性 ，**主从复制**

## 事务

原子性、一致性、隔离性、持久性，这四个属性通常称为ACID特性。


# MyBatis 动态 SQL 底层原理分析

## MyBatis初始化过程  (链接)[https://blog.csdn.net/danmoo1/article/details/79529827]
## 2.1 获取配置文件 - （2）->  创建SqlSessionFactoryBuilder对象  -->创建`SqlSessionFactory`对象的   -->创建 SqlSession 

SqlSessionFactoryBuilder：配置文件创建SqlSessionFactory对象的
一：
当系统初始化时，首先会读取配置文件，并将其解析成InputStream 
``java 
String resource = "mybatis.xml"; 
InputStream inputStream = Resources.getResourceAsStream(resource);
 ``
（2）如下 
1.`XMLConfigBuilder`用来解析MyBatis的配置文件，`XMLMapperBuilder`用来解析MyBatis中的映射文件（如`UserMapper.xml`)，`XMLStatementBuilder`用来解析映射文件中的SQL语句
2.这些`XMLxxxBuilder`都有一个共同的父类——`BaseBuilder`。这个父类维护了一个全局的`Configuration`对象，MyBatis的配置文件解析后就以`Configuration`对象的形式存储。
3.`XMLConfigBuilder`对象之后，接下来就可以用它来解析配置文件，`<properties>`、`< settings >`、`< environments>`、`< typeAliases >`、`< plugins >`、`< mappers >`等属性，分别有节点解析如propertiesElement，（1.properties文件中的键值对，2.并添加至defaults容器，3.defaults容器添加至configuration中）
typeAliasesElement，（1遍历<typeAliases>下的所有子节点 ，2 获取alias和type属性，3注册进configuration的typeAliasRegistry）
4.如果当前节点为`<mapper>`，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到`configuration`的`mapperRegistry`容器中 ,在解析前
4.1，首先需要创建`XMLMapperBuilder` ，解析`<mapper>`的过程，其中有`configurationElement`函数，`resultMapElements`函数（所有的`<resultMap>`节点，这些节点会被解析成`ResultMap`对象）；`sqlElement`函数（所有的`<sql>`节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中）
5.`XMLConfigBuilder`解析映射文件的过程，解析完成之后`parser.parse()`函数会返回一个包含了映射文件解析结果的`configuration`对象，传给个build函数 ，创建sqlsessionfactory

## **MyBatis的SQL查询流程**

1.** 该过程就是通过封装JDBC进行操作，然后使用Java反射技术完成JavaBean对象到数据库参数之间的相互转换**
2.在selectList中，会查询configuration中存储的MappedStatement对象
3.执行器在query操作中，优先会查询缓存是否命中，命中则直接返回，否则从数据库中查询。

##  **MyBatis缓存**


一级缓存是SqlSession级别的缓存，每个SqlSession对象都有一个哈希表用于缓存数据，不同SqlSession对象之间缓存不共享。同一个SqlSession对象对象执行2遍相同的SQL查询，在第一次查询执行完毕后将结果缓存起来，这样第二遍查询就不用向数据库查询了，直接返回缓存结果即可。MyBatis默认是开启一级缓存的。

二级缓存是mapper级别的缓存，二级缓存是跨SqlSession的，多个SqlSession对象可以共享同一个二级缓存。不同的SqlSession对象执行两次相同的SQL语句，第一次会将查询结果进行缓存，第二次查询直接返回二级缓存中的结果即可。MyBatis默认是不开启二级缓存的，可以在配置文件中使用如下配置来开启二级缓存：

<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>

**MyBatis的主要成员**
*   Configuration        MyBatis所有的配置信息都保存在Configuration对象之中，配置文件中的大部分配置都会存储到该类中
*   SqlSession            作为MyBatis工作的主要顶层API，表示和数据库交互时的会话，完成必要数据库增删改查功能
*   Executor               MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
*   StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等
*   ParameterHandler  负责对用户传递的参数转换成JDBC Statement 所对应的数据类型
*   ResultSetHandler   负责将JDBC返回的ResultSet结果集对象转换成List类型的集合
*   TypeHandler          负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换
*   MappedStatement  MappedStatement维护一条<select|update|delete|insert>节点的封装
*   SqlSource              负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
*   BoundSql              表示动态生成的SQL语句以及相应的参数信息

# mybatis与hibernate的对比

（1）Hibernate与MyBatis都是通过SessionFactoryBuider由XML配置文件生成SessionFactory，由SessionFactory 生成Session，由Session来开启执行事务和SQL(Structured Query Language，结构化查询语言)语句
 （2）Hibernate和MyBatis都支持JDBC  事务处理
  不同点：
（1）Hibernate与MyBatis都是通过SessionFactoryBuider由XML配置文件生成SessionFactory，由SessionFactory 生成Session，由Session来开启执行事务和SQL(Structured Query Language，结构化查询语言)语句

##  nosql和Mysql的区别
1.事务处理保持数据一致性
2. 数据开销小，可以支持join 复杂查询
nosql：
1.简单扩展2.快速的读写 （例如redis）3.成本低4.不提供sql支持


# [Redis与Memcached ，mongoDB的区别](http://www.cnblogs.com/wangkai1990/p/5212404.html)
1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；

2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；
3、存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；
4，mongodb支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富，mongoDB不支持事务，mongoDB内置了数据分析的功能



##  高并发
###