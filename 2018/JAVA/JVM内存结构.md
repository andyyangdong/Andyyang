# JVM内存结构

##  JVM内存结构

>* 程序计数器 ：java虚拟机是采用多线程，通过线程切换获得时间片得到CPU的控制权。需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
>* 虚拟机栈，调用一个方法时会创建一个栈帧，用于存储局部变量，对象引用，方法返回值，每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
>* 本地方法栈，与虚拟机栈相似，**本地方法栈则是为虚拟机使用到的Native方法服务**
>* 堆（堆），所有线程共享，通过新的操作产生对象，存放对象实例，分为年轻代（伊甸两个幸存者）和年老代
>* 方法区：主要是类信息，常量，静态变量，也叫持久代，通过-XXMaxPerSize控制大小  永生区

>* 堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，**Eden空间**、**From Survivor空间**、**To Survivor空间**,默认情况下年轻代按照**8:1:1**的比例来分配
>* GC又分为minor GC 和 Full GC（major GC）

##   触发JVM进行minor GC的情

Minor GC的触发条件：大多数情况下，直接在eden区中进行分配。如果eden区域没有足够的空间，

##   触发JVM进行Full GC的情

### **1、System.gc()方法的调用**

###  2、老年代代空间不足  
老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间

## 3、永生区空间不足

## 4、统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间

## 6、堆中分配很大的对象

 ### GC Easy

通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况


